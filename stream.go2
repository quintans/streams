package main

import (
	"fmt"
	"log"
	"time"
)

type Observer[T any] struct {
	Next     func(data T) bool
	Error    func(e error)
	Complete func()
}

type Subscription func()
type Stream[T any] func(observer Observer[T]) Subscription
type Operator[T, U any] func(source Stream[T]) Stream[U]

func Periodic(interval time.Duration) Stream[int] {
	return func(observer Observer[int]) Subscription {
		i := 0
		ticker := time.NewTicker(interval)
		done := make(chan bool, 1)
		unsub := func() {
			ticker.Stop()
			done <- true
			if observer.Complete != nil {
				observer.Complete()
			}
		}
		go func() {
			for {
				select {
				case <-done:
					return
				case <-ticker.C:
					ok := observer.Next(i)
					if !ok {
						unsub()
					}
					i++
				}
			}
		}()

		return unsub
	}
}

func From[T any](args ...T) Stream[T] {
	return func(observer Observer[T]) Subscription {
		for _, v := range args {
			ok := observer.Next(v)
			if !ok {
				break
			}
		}
		if observer.Complete != nil {
			observer.Complete()
		}

		return func() {}
	}
}

func Subscribe[T any](obs Observer[T]) func(source Stream[T]) Subscription {
	return func(source Stream[T]) Subscription {
		return source(obs)
	}
}

func Collect[T any](f func(T) bool) func(source Stream[T]) Subscription {
	obs := Observer[T]{
		Next: f,
	}
	return func(source Stream[T]) Subscription {
		return source(obs)
	}
}

func Map[T, U any](f func(x T) U) Operator[T, U] {
	return func(source Stream[T]) Stream[U] {
		return func(observer Observer[U]) Subscription {
			return source(Observer[T]{
				Next: func(data T) bool {
					return observer.Next(f(data))
				},
				Error:    observer.Error,
				Complete: observer.Complete,
			})
		}
	}
}

func Take[T any](n int) Operator[T, T] {
	return func(source Stream[T]) Stream[T] {
		return func(observer Observer[T]) Subscription {
			i := 0
			return source(Observer[T]{
				Next: func(data T) bool {
					ok := observer.Next(data)
					i++
					if !ok || i == n {
						return false
					}
					return ok
				},
				Error:    observer.Error,
				Complete: observer.Complete,
			})
		}
	}
}

func Merge[T any](streams ...Stream[T]) Stream[T] {
	return func(observer Observer[T]) Subscription {
		unsubscribes := make([]Subscription, len(streams))
		numCompleted := 0

		for i, stream := range streams {
			unsubscribes[i] = stream(Observer[T]{
				Next: observer.Next,
				Complete: func() {
					numCompleted++
					if numCompleted == len(streams) {
						if observer.Complete != nil {
							observer.Complete()
						}
					}
				},
				Error: observer.Error,
			})
		}

		return func() {
			for _, unsub := range unsubscribes {
				unsub()
			}
		}
	}
}

func Scan[T, U any](initialValue U, f func(acc U, current T) U) Operator[T, U] {
	return func(source Stream[T]) Stream[U] {
		return func(observer Observer[U]) Subscription {
			current := initialValue
			ok := observer.Next(current)
			if !ok {
				return func() {}
			}
			return source(Observer[T]{
				Next: func(data T) bool {
					current = f(current, data)
					return observer.Next(current)
				},
				Error:    observer.Error,
				Complete: observer.Complete,
			})
		}
	}
}

func StartWith[T any](data T) Operator[T, T] {
	return func(source Stream[T]) Stream[T] {
		return func(observer Observer[T]) Subscription {
			ok := observer.Next(data)
			if !ok {
				return func() {}
			}
			return source(observer)
		}
	}
}

func Flatten[T any](outer Stream[Stream[T]]) Stream[T] {
	return func(observer Observer[T]) Subscription {
		var innerSub Subscription
		outerCompleted := false

		unsubscribe := outer(Observer[Stream[T]]{
			Next: func(stream Stream[T]) bool {
				if innerSub != nil {
					innerSub()
				}

				innerSub = stream(Observer[T]{
					Next: func(data T) bool {
						return observer.Next(data)
					},
					Error: observer.Error,
					Complete: func() {
						innerSub = nil
						if outerCompleted && observer.Complete != nil {
							observer.Complete()
						}
					},
				})
				return true
			},
			Error: observer.Error,
			Complete: func() {
				outerCompleted = true
			},
		})

		return func() {
			unsubscribe()
			if innerSub != nil {
				innerSub()
			}
		}
	}
}

func main() {
	fmt.Println("--- From, Scan & Collect ---")
	p := From(1, 2, 3)
	r := Scan(10, func(acc, i int) int {
		return acc + i
	})(p)
	val := 0
	Collect(func(i int) bool {
		val = i
		fmt.Println(i)
		return true
	})(r)
	if val != 16 {
		log.Fatalf("expected 16, got %d", val)
	}

	// ===
	fmt.Println("--- From, Flatten & Collect ---")
	o := From(1, 3, 5)
	x := Map(func(x int) Stream[int] {
		return From(x)
	})(o)
	f := Flatten(x)
	cnt := 0
	Collect(func(i int) bool {
		cnt++
		val = i
		fmt.Println(i)
		return true
	})(f)
	if cnt != 3 {
		log.Fatalf("expected 3, got %d", cnt)
	}

	// ====
	fmt.Println("--- From, Take, Map & Collect ---")
	p0 := From(1, 2, 3, 4, 5, 6)
	t0 := Take[int](5)(p0)
	m0 := Map(func(i int) int {
		return i * 2
	})(t0)
	s0 := StartWith(10)(m0)
	cnt = 0
	Collect(func(i int) bool {
		cnt++
		fmt.Println(i)
		return true
	})(s0)
	if cnt != 6 {
		log.Fatalf("expected 6, got %d", cnt)
	}

	// ===
	fmt.Println("--- Periodic, Take, Map & Subscribe ---")
	p2 := Periodic(500 * time.Millisecond)
	t2 := Take[int](5)(p2)
	m2 := Map(func(i int) int {
		return i * 2
	})(t2)

	cnt = 0
	Subscribe(Observer[int]{
		Next: func(i int) bool {
			fmt.Println(i)
			cnt++
			return true
		},
		Complete: func() {
			fmt.Println("We are done")
		},
	})(m2)

	time.Sleep(3 * time.Second)
	if cnt != 5 {
		log.Fatalf("expected 5, got %d", cnt)
	}

	// ====
	fmt.Println("--- From, Periodic, Merge, Take, Map & Collect ---")
	p3 := Periodic(500 * time.Millisecond)
	f3 := From(10, 20)
	p3 = Merge(f3, p3)
	t3 := Take[int](5)(p3)
	m3 := Map(func(i int) int {
		return i * 2
	})(t3)

	cnt = 0
	Collect(func(i int) bool {
		cnt++
		fmt.Println(i)
		return true
	})(m3)

	time.Sleep(3 * time.Second)
	if cnt != 5 {
		log.Fatalf("expected 5, got %d", cnt)
	}

	fmt.Println("Done")
}
